<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vigenère</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:rgba(255,255,255,.08);
      --text:#eaf0ff;
      --muted:rgba(234,240,255,.7);
      --border:rgba(255,255,255,.14);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:radial-gradient(1200px 900px at 20% 10%, #192a5a 0%, transparent 55%),
                 radial-gradient(900px 700px at 80% 20%, #3a1a6a 0%, transparent 55%),
                 var(--bg);
      color:var(--text);
      min-height:100vh;
      display:grid;
      place-items:center;
      padding:24px;
    }
    .wrap{width:min(1080px,100%);display:grid;gap:14px}
    .header{display:flex;align-items:baseline;justify-content:space-between;flex-wrap:wrap;gap:12px}
    h1{font-size:20px;margin:0}
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:16px;
      backdrop-filter:blur(8px);
    }
    label{display:block;color:var(--muted);font-size:13px;margin-bottom:8px}
    input[type="text"], input[type="number"], textarea, select{
      width:100%;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--text);
      padding:10px 12px;
      outline:none;
    }
    textarea{
      min-height:150px;
      resize:vertical;
      line-height:1.45;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      font-size:13px;
    }
    input[type="text"]::placeholder,
    textarea::placeholder{
      color:rgba(234,240,255,.45);
    }
    input[type="text"]:focus,
    input[type="number"]:focus,
    textarea:focus,
    select:focus{
      border-color:rgba(122,167,255,.7);
      box-shadow:0 0 0 3px rgba(122,167,255,.18);
    }
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    @media (max-width:860px){.grid{grid-template-columns:1fr}}
    .row{display:grid;grid-template-columns:1fr 1fr 1fr;gap:14px}
    @media (max-width:860px){.row{grid-template-columns:1fr}}

    .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    button{
      border:1px solid var(--border);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      transition:transform .05s ease, background .15s ease, border-color .15s ease;
    }
    button:hover{background:rgba(255,255,255,.10);border-color:rgba(122,167,255,.5)}
    button:active{transform:translateY(1px)}
    .primary{background:rgba(122,167,255,.20);border-color:rgba(122,167,255,.55)}
    .small{font-size:12px;padding:8px 10px;border-radius:10px}
    .tiny{font-size:12px;color:var(--muted);margin-top:6px;line-height:1.35}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}

    details{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      background:rgba(0,0,0,.15);
      margin-top:12px;
    }
    summary{cursor:pointer;font-weight:700;color:var(--text);outline:none}

    .subgrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width:860px){.subgrid{grid-template-columns:1fr}}

    .checkrow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top: 8px;
    }
    .checkrow label{
      margin:0;
      display:flex;
      gap:8px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .checkrow input[type="checkbox"]{
      width:auto;
      transform: translateY(1px);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <h1>Vigenère</h1>
    </div>

    <div class="card">
      <div class="row">
        <div>
          <label for="key">Key</label>
          <input id="key" type="text" value="" placeholder="ENTER A KEY..." autocomplete="off" />
        </div>

        <div>
          <label for="mode">Mode</label>
          <select id="mode">
            <option value="encode" selected>Encode</option>
            <option value="decode">Decode</option>
          </select>
        </div>

        <div>
          <label for="nonalpha">Handling</label>
          <select id="nonalpha">
            <option value="keep">Keep</option>
            <option value="strip">Strip</option>
            <option value="tokenize">Tokenize</option>
            <option value="mapping" selected>Mapping</option>
          </select>
        </div>
      </div>

      <details id="keyPanel">
        <summary>Key options</summary>

        <div class="subgrid">
          <div>
            <label for="keyPattern">Pattern</label>
            <select id="keyPattern">
              <option value="base" selected>Base</option>
              <option value="base_rev">Base + Reverse</option>
              <option value="rev_base">Reverse + Base</option>
              <option value="base_rev_base">Base + Reverse + Base</option>
              <option value="rev_base_rev">Reverse + Base + Reverse</option>
              <option value="base_rev_rev_base">Base + Reverse + Reverse + Base</option>
              <option value="alt_base">Alternate Base/Reverse (start Base)</option>
              <option value="alt_rev">Alternate Base/Reverse (start Reverse)</option>
            </select>
          </div>

          <div>
            <label for="altParts">Alternate parts</label>
            <input id="altParts" type="number" min="1" max="50" value="2" />
          </div>
        </div>

        <div class="subgrid">
          <div>
            <label for="repeatBuilt">Repeat result</label>
            <input id="repeatBuilt" type="number" min="1" max="50" value="1" />
          </div>

          <div>
            <label for="targetLen">Cut to length (0 = off)</label>
            <input id="targetLen" type="number" min="0" max="200000" value="0" />
          </div>
        </div>

        <div class="checkrow">
          <label><input id="overlapJoin" type="checkbox" /> Overlap join</label>
          <label><input id="showBuiltKey" type="checkbox" checked /> Show built key</label>
        </div>

        <div id="builtKeyWrap" style="margin-top:10px;">
          <label for="builtKey">Built key</label>
          <input id="builtKey" class="mono" type="text" readonly placeholder="(BUILT KEY)" />
        </div>
      </details>

      <div style="height: 10px"></div>

      <div class="row">
        <div>
          <label for="stripSpaces">Spacing</label>
          <select id="stripSpaces">
            <option value="keepSpaces" selected>Keep spaces</option>
            <option value="noSpaces">Remove spaces</option>
          </select>
        </div>

        <div>
          <label for="caseMode">Case</label>
          <select id="caseMode">
            <option value="preserve">Preserve</option>
            <option value="upper" selected>UPPERCASE</option>
            <option value="lower">lowercase</option>
          </select>
        </div>

        <div>
          <label for="autoRun">Auto-run</label>
          <select id="autoRun">
            <option value="on" selected>On</option>
            <option value="off">Off</option>
          </select>
        </div>
      </div>

      <details id="mappingPanel">
        <summary>Mapping list</summary>
        <div style="height: 10px"></div>
        <label for="codebook">Mappings</label>
        <textarea id="codebook" rows="10" placeholder="ZAA=!&#10;ZAB=?&#10;..."></textarea>
        <div class="btns">
          <button class="small" id="resetCodebookBtn">Reset defaults</button>
          <button class="small" id="validateCodebookBtn">Validate</button>
        </div>
        <div class="tiny" id="codebookStatus"></div>
      </details>

      <div style="height: 12px"></div>

      <div class="grid">
        <div>
          <label for="input">Input</label>
          <textarea id="input" placeholder="TYPE OR PASTE TEXT HERE..."></textarea>
        </div>
        <div>
          <label for="output">Output</label>
          <textarea id="output" readonly placeholder="OUTPUT WILL APPEAR HERE..."></textarea>
        </div>
      </div>

      <div class="btns">
        <button class="primary" id="runBtn">Run</button>
        <button id="swapBtn">Swap</button>
        <button class="small" id="copyBtn">Copy</button>
        <button class="small" id="clearBtn">Clear</button>
      </div>
    </div>
  </div>

  <script>
    // ---------- helpers ----------
    function lettersOnly(str){ return (str || "").replace(/[^A-Za-z]/g, ""); }
    function reverseStr(s){ return s.split("").reverse().join(""); }
    function concatWithOverlap(a, b, overlap){
      if (!overlap) return a + b;
      if (!a || !b) return a + b;
      const la = a[a.length - 1].toLowerCase();
      const fb = b[0].toLowerCase();
      return (la === fb) ? (a + b.slice(1)) : (a + b);
    }
    function repeatJoin(base, times, overlap){
      let out = "";
      for (let i = 0; i < times; i++){
        out = concatWithOverlap(out, base, overlap);
      }
      return out;
    }

    function buildKey(rawBase, pattern, altParts, repeatBuilt, targetLen, overlap){
      const base = lettersOnly(rawBase);
      const rev = reverseStr(base);

      let segments = [];

      switch (pattern){
        case "base": segments = [base]; break;
        case "base_rev": segments = [base, rev]; break;
        case "rev_base": segments = [rev, base]; break;
        case "base_rev_base": segments = [base, rev, base]; break;
        case "rev_base_rev": segments = [rev, base, rev]; break;
        case "base_rev_rev_base": segments = [base, rev, rev, base]; break;

        case "alt_base": {
          const n = Math.max(1, Math.min(50, Number(altParts) || 1));
          segments = Array.from({length:n}, (_,i)=> (i % 2 === 0 ? base : rev));
          break;
        }
        case "alt_rev": {
          const n = Math.max(1, Math.min(50, Number(altParts) || 1));
          segments = Array.from({length:n}, (_,i)=> (i % 2 === 0 ? rev : base));
          break;
        }
        default: segments = [base];
      }

      let built = "";
      for (const seg of segments){
        built = concatWithOverlap(built, seg, overlap);
      }

      const rep = Math.max(1, Math.min(50, Number(repeatBuilt) || 1));
      built = repeatJoin(built, rep, overlap);

      const L = Math.max(0, Math.floor(Number(targetLen) || 0));
      if (L > 0){
        if (built.length === 0) return "";
        while (built.length < L) built = concatWithOverlap(built, built, false);
        built = built.slice(0, L);
      }

      return built;
    }

    // ---------- Vigenère core ----------
    function isUpper(ch){const c=ch.charCodeAt(0);return c>=65&&c<=90}
    function isLower(ch){const c=ch.charCodeAt(0);return c>=97&&c<=122}
    function alphaIndex(ch){
      const code=ch.charCodeAt(0);
      if (isUpper(ch)) return code-65;
      if (isLower(ch)) return code-97;
      return -1;
    }
    function sanitizeKey(keyRaw){
      const shifts=[];
      for (const ch of keyRaw){
        const idx=alphaIndex(ch);
        if (idx!==-1) shifts.push(idx);
      }
      return shifts;
    }
    function shiftChar(ch, shift, direction){
      const idx=alphaIndex(ch);
      if (idx===-1) return ch;
      const base=isUpper(ch)?65:97;
      const moved=(idx + direction*shift) % 26;
      const wrapped=(moved + 26) % 26;
      return String.fromCharCode(base + wrapped);
    }
    function applyCaseMode(str, caseMode){
      if (caseMode==="upper") return str.toUpperCase();
      if (caseMode==="lower") return str.toLowerCase();
      return str;
    }
    function vigenere(text, keyRaw, mode){
      const key=sanitizeKey(keyRaw);
      if (key.length===0) return text;
      const direction=(mode==="decode")?-1:1;

      let ki=0, out="";
      for (const ch of text){
        const idx=alphaIndex(ch);
        if (idx===-1){ out+=ch; continue; }
        const shift=key[ki % key.length];
        out+=shiftChar(ch, shift, direction);
        ki++;
      }
      return out;
    }

    // ---------- Tokenize mode (spell-out) ----------
    const DIGIT_WORDS=["ZERO","ONE","TWO","THREE","FOUR","FIVE","SIX","SEVEN","EIGHT","NINE"];
    const PUNCT_TOKENS=new Map([
      [" ","SPACE"],[".","DOT"],[",","COMMA"],["!","EXCLAMATION"],["?","QUESTION"],
      [":","COLON"],[";","SEMICOLON"],["-","DASH"],["_","UNDERSCORE"],
      ["'","APOSTROPHE"],["\"","QUOTE"],["(","LPAREN"],[")","RPAREN"],
      ["[","LBRACKET"],["]","RBRACKET"],["{","LBRACE"],["}","RBRACE"],
      ["@","AT"],["#","HASH"],["$","DOLLAR"],["%","PERCENT"],["&","AMPERSAND"],
      ["*","ASTERISK"],["/","SLASH"],["\\","BACKSLASH"],["+","PLUS"],["=","EQUALS"]
    ]);
    const TOKEN_TO_PUNCT=(()=>{
      const rev=new Map();
      for (const [k,v] of PUNCT_TOKENS.entries()) rev.set(v,k);
      DIGIT_WORDS.forEach((w,i)=>rev.set(w,String(i)));
      return rev;
    })();

    function normalizeStrip(text, keepSpaces){
      let out="";
      for (const ch of text){
        const idx=alphaIndex(ch);
        if (idx!==-1) out+=ch;
        else if (keepSpaces && ch===" ") out+=" ";
      }
      return out;
    }

    function tokenizeSpell(text, keepSpaces){
      const parts=[];
      for (const ch of text){
        const idx=alphaIndex(ch);
        if (idx!==-1){ parts.push(ch); continue; }
        if (ch>="0" && ch<="9"){ parts.push(DIGIT_WORDS[ch.charCodeAt(0)-48]); continue; }
        if (PUNCT_TOKENS.has(ch)){
          const tok=PUNCT_TOKENS.get(ch);
          if (tok==="SPACE"){ if (keepSpaces) parts.push("SPACE"); }
          else parts.push(tok);
          continue;
        }
        const code=ch.codePointAt(0);
        parts.push("CHAR"+code.toString(16).toUpperCase());
      }
      return parts.join(" ");
    }

    function detokenizeSpell(tokenText){
      const tokens=tokenText.trim().split(/\s+/).filter(Boolean);
      let out="";
      for (const t of tokens){
        const up=t.toUpperCase();
        if (up.startsWith("CHAR")){
          const hex=up.slice(4);
          const code=parseInt(hex,16);
          out += Number.isNaN(code) ? t : String.fromCodePoint(code);
          continue;
        }
        if (up==="SPACE"){ out+=" "; continue; }
        if (TOKEN_TO_PUNCT.has(up)){ out+=TOKEN_TO_PUNCT.get(up); continue; }
        if (/^[A-Z]$/i.test(t)){ out+=t; continue; }
        out+="["+t+"]";
      }
      return out;
    }

    // ---------- Mapping mode ----------
    const DEFAULT_MAPPING_TEXT =
`ZAA=!
ZAB=?
ZAC=.
ZAD=,
ZAE=:
ZAF=;
ZAG=-
ZAH=@
ZAI=#
ZAJ=$
ZAK=%
ZAL=&
ZAM=(
ZAN=)
ZAO=0
ZAP=1
ZAQ=2
ZAR=3
ZAS=4
ZAT=5
ZAU=6
ZAV=7
ZAW=8
ZAX=9
ZAY=SPACE
ZZZ=Z`;

    function parseMapping(text){
      const tokenToChar=new Map();
      const charToToken=new Map();
      const errors=[];

      const lines=text.split(/\r?\n/);
      for (let li=0; li<lines.length; li++){
        const raw=lines[li].trim();
        if (!raw || raw.startsWith("#")) continue;

        const m=raw.match(/^([A-Za-z]{3})\s*=\s*(.+)$/);
        if (!m){ errors.push(`LINE ${li+1}: INVALID FORMAT`); continue; }

        const token=m[1].toUpperCase();
        const rhs=m[2];
        const ch = (rhs.toUpperCase()==="SPACE") ? " " : rhs[0];

        if (!/^[A-Z]{3}$/.test(token)){ errors.push(`LINE ${li+1}: TOKEN MUST BE 3 LETTERS`); continue; }
        if (tokenToChar.has(token)) errors.push(`LINE ${li+1}: DUPLICATE TOKEN ${token}`);
        if (charToToken.has(ch)) errors.push(`LINE ${li+1}: DUPLICATE CHAR MAPPING ${JSON.stringify(ch)}`);

        tokenToChar.set(token,ch);
        charToToken.set(ch,token);
      }

      return { tokenToChar, charToToken, errors };
    }

    function mappingEncodePreprocess(plaintext, mp, keepSpaces){
      let out="";
      for (const ch of plaintext){
        const idx=alphaIndex(ch);

        if (idx!==-1){
          if (ch==="Z" || ch==="z"){
            const tok=mp.charToToken.get("Z");
            if (tok) out+=tok;
            else out+=ch;
          } else out+=ch;
          continue;
        }

        if (ch===" "){
          if (!keepSpaces) continue;
          const tok=mp.charToToken.get(" ");
          if (tok) out+=tok;
          continue;
        }

        const tok=mp.charToToken.get(ch);
        if (tok) out+=tok;
      }
      return out;
    }

    function mappingDecodePostprocess(decodedLettersOnly, mp){
      let out="";
      const text=decodedLettersOnly;

      for (let i=0; i<text.length;){
        if (i+2<text.length){
          const tok=text.substring(i,i+3).toUpperCase();
          if (mp.tokenToChar.has(tok)){
            out += mp.tokenToChar.get(tok);
            i += 3;
            continue;
          }
        }
        out += text[i];
        i++;
      }
      return out;
    }

    // ---------- UI ----------
    const keyEl=document.getElementById("key");
    const modeEl=document.getElementById("mode");
    const handlingEl=document.getElementById("nonalpha");
    const spacingEl=document.getElementById("stripSpaces");
    const caseEl=document.getElementById("caseMode");
    const autoRunEl=document.getElementById("autoRun");

    const keyPanel=document.getElementById("keyPanel");
    const keyPatternEl=document.getElementById("keyPattern");
    const altPartsEl=document.getElementById("altParts");
    const repeatBuiltEl=document.getElementById("repeatBuilt");
    const targetLenEl=document.getElementById("targetLen");
    const overlapJoinEl=document.getElementById("overlapJoin");
    const showBuiltKeyEl=document.getElementById("showBuiltKey");
    const builtKeyWrap=document.getElementById("builtKeyWrap");
    const builtKeyEl=document.getElementById("builtKey");

    const mappingPanel=document.getElementById("mappingPanel");
    const mappingEl=document.getElementById("codebook");
    const mappingStatusEl=document.getElementById("codebookStatus");
    const resetMappingBtn=document.getElementById("resetCodebookBtn");
    const validateMappingBtn=document.getElementById("validateCodebookBtn");

    const inputEl=document.getElementById("input");
    const outputEl=document.getElementById("output");

    const runBtn=document.getElementById("runBtn");
    const swapBtn=document.getElementById("swapBtn");
    const copyBtn=document.getElementById("copyBtn");
    const clearBtn=document.getElementById("clearBtn");

    function updateMappingVisibility(){
      mappingPanel.style.display = (handlingEl.value==="mapping") ? "" : "none";
    }

    function validateMapping(){
      const mp=parseMapping(mappingEl.value);
      if (mp.errors.length){
        mappingStatusEl.textContent = "ISSUES:\n- " + mp.errors.join("\n- ");
        mappingStatusEl.style.whiteSpace="pre-wrap";
        mappingStatusEl.style.color="rgba(255,200,200,.95)";
      } else {
        mappingStatusEl.textContent = "OK";
        mappingStatusEl.style.whiteSpace="normal";
        mappingStatusEl.style.color="rgba(180,255,210,.95)";
      }
      return mp;
    }

    function computeBuiltKey(){
      const built = buildKey(
        keyEl.value,
        keyPatternEl.value,
        altPartsEl.value,
        repeatBuiltEl.value,
        targetLenEl.value,
        overlapJoinEl.checked
      );
      builtKeyEl.value = built;
      builtKeyWrap.style.display = showBuiltKeyEl.checked ? "" : "none";
      return built;
    }

    function process(input, builtKey, cipherMode, handling, spacingMode, caseMode, mappingText){
      const keepSpaces = (spacingMode==="keepSpaces");

      if (cipherMode==="encode"){
        let pre=input;

        if (handling==="strip"){
          pre=normalizeStrip(pre, keepSpaces);
        } else if (handling==="tokenize"){
          pre=tokenizeSpell(pre, keepSpaces);
          if (!keepSpaces) pre=pre.replace(/\s+/g,"");
        } else if (handling==="mapping"){
          const mp=parseMapping(mappingText);
          pre=mappingEncodePreprocess(pre, mp, keepSpaces);
        }

        let out=vigenere(pre, builtKey, "encode");
        out=applyCaseMode(out, caseMode);
        return out;
      } else {
        let dec=vigenere(input, builtKey, "decode");
        dec=applyCaseMode(dec, caseMode);

        if (handling==="tokenize"){
          if (keepSpaces) return detokenizeSpell(dec);
          return dec;
        }
        if (handling==="mapping"){
          const mp=parseMapping(mappingText);
          return mappingDecodePostprocess(dec, mp);
        }
        return dec;
      }
    }

    function run(){
      const builtKey = computeBuiltKey();
      outputEl.value = process(
        inputEl.value,
        builtKey,
        modeEl.value,
        handlingEl.value,
        spacingEl.value,
        caseEl.value,
        mappingEl.value
      );
      if (handlingEl.value==="mapping") validateMapping();
    }

    function maybeRun(){ if (autoRunEl.value==="on") run(); }

    // events
    resetMappingBtn.addEventListener("click", ()=>{
      mappingEl.value = DEFAULT_MAPPING_TEXT;
      validateMapping();
      maybeRun();
    });
    validateMappingBtn.addEventListener("click", validateMapping);

    runBtn.addEventListener("click", run);

    [
      keyEl, modeEl, handlingEl, spacingEl, caseEl, inputEl, autoRunEl, mappingEl,
      keyPatternEl, altPartsEl, repeatBuiltEl, targetLenEl, overlapJoinEl, showBuiltKeyEl
    ].forEach(el => el.addEventListener("input", maybeRun));

    modeEl.addEventListener("change", maybeRun);
    handlingEl.addEventListener("change", ()=>{
      updateMappingVisibility();
      maybeRun();
    });
    spacingEl.addEventListener("change", maybeRun);
    caseEl.addEventListener("change", maybeRun);
    autoRunEl.addEventListener("change", ()=>{ if (autoRunEl.value==="on") run(); });
    keyPatternEl.addEventListener("change", ()=>{
      const isAlt = keyPatternEl.value === "alt_base" || keyPatternEl.value === "alt_rev";
      altPartsEl.disabled = !isAlt;
      maybeRun();
    });
    showBuiltKeyEl.addEventListener("change", ()=>{
      builtKeyWrap.style.display = showBuiltKeyEl.checked ? "" : "none";
    });

    swapBtn.addEventListener("click", ()=>{
      const tmp=inputEl.value;
      inputEl.value=outputEl.value;
      outputEl.value=tmp;
      if (autoRunEl.value==="on") run();
      inputEl.focus();
    });

    copyBtn.addEventListener("click", async ()=>{
      try { await navigator.clipboard.writeText(outputEl.value); }
      catch { outputEl.focus(); outputEl.select(); document.execCommand("copy"); }
      copyBtn.textContent="COPIED";
      setTimeout(()=> (copyBtn.textContent="COPY"), 900);
    });

    clearBtn.addEventListener("click", ()=>{
      inputEl.value="";
      outputEl.value="";
      inputEl.focus();
    });

    // init
    mappingEl.value = DEFAULT_MAPPING_TEXT;
    mappingPanel.open = false;
    keyPanel.open = false;
    altPartsEl.disabled = true;

    updateMappingVisibility();
    run();
  </script>
</body>
</html>